// Code generated by MockGen. DO NOT EDIT.
// Source: go.abhg.dev/gs/internal/forge (interfaces: Forge,Repository)
//
// Generated by this command:
//
//	mockgen -destination=forgetest/mocks.go -package forgetest -typed . Forge,Repository
//

// Package forgetest is a generated GoMock package.
package forgetest

import (
	context "context"
	json "encoding/json"
	iter "iter"
	reflect "reflect"

	forge "go.abhg.dev/gs/internal/forge"
	secret "go.abhg.dev/gs/internal/secret"
	ui "go.abhg.dev/gs/internal/ui"
	gomock "go.uber.org/mock/gomock"
)

// MockForge is a mock of Forge interface.
type MockForge struct {
	ctrl     *gomock.Controller
	recorder *MockForgeMockRecorder
	isgomock struct{}
}

// MockForgeMockRecorder is the mock recorder for MockForge.
type MockForgeMockRecorder struct {
	mock *MockForge
}

// NewMockForge creates a new mock instance.
func NewMockForge(ctrl *gomock.Controller) *MockForge {
	mock := &MockForge{ctrl: ctrl}
	mock.recorder = &MockForgeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockForge) EXPECT() *MockForgeMockRecorder {
	return m.recorder
}

// AuthenticationFlow mocks base method.
func (m *MockForge) AuthenticationFlow(ctx context.Context, view ui.View) (forge.AuthenticationToken, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AuthenticationFlow", ctx, view)
	ret0, _ := ret[0].(forge.AuthenticationToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AuthenticationFlow indicates an expected call of AuthenticationFlow.
func (mr *MockForgeMockRecorder) AuthenticationFlow(ctx, view any) *MockForgeAuthenticationFlowCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationFlow", reflect.TypeOf((*MockForge)(nil).AuthenticationFlow), ctx, view)
	return &MockForgeAuthenticationFlowCall{Call: call}
}

// MockForgeAuthenticationFlowCall wrap *gomock.Call
type MockForgeAuthenticationFlowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeAuthenticationFlowCall) Return(arg0 forge.AuthenticationToken, arg1 error) *MockForgeAuthenticationFlowCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeAuthenticationFlowCall) Do(f func(context.Context, ui.View) (forge.AuthenticationToken, error)) *MockForgeAuthenticationFlowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeAuthenticationFlowCall) DoAndReturn(f func(context.Context, ui.View) (forge.AuthenticationToken, error)) *MockForgeAuthenticationFlowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CLIPlugin mocks base method.
func (m *MockForge) CLIPlugin() any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CLIPlugin")
	ret0, _ := ret[0].(any)
	return ret0
}

// CLIPlugin indicates an expected call of CLIPlugin.
func (mr *MockForgeMockRecorder) CLIPlugin() *MockForgeCLIPluginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CLIPlugin", reflect.TypeOf((*MockForge)(nil).CLIPlugin))
	return &MockForgeCLIPluginCall{Call: call}
}

// MockForgeCLIPluginCall wrap *gomock.Call
type MockForgeCLIPluginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeCLIPluginCall) Return(arg0 any) *MockForgeCLIPluginCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeCLIPluginCall) Do(f func() any) *MockForgeCLIPluginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeCLIPluginCall) DoAndReturn(f func() any) *MockForgeCLIPluginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ChangeTemplatePaths mocks base method.
func (m *MockForge) ChangeTemplatePaths() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeTemplatePaths")
	ret0, _ := ret[0].([]string)
	return ret0
}

// ChangeTemplatePaths indicates an expected call of ChangeTemplatePaths.
func (mr *MockForgeMockRecorder) ChangeTemplatePaths() *MockForgeChangeTemplatePathsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeTemplatePaths", reflect.TypeOf((*MockForge)(nil).ChangeTemplatePaths))
	return &MockForgeChangeTemplatePathsCall{Call: call}
}

// MockForgeChangeTemplatePathsCall wrap *gomock.Call
type MockForgeChangeTemplatePathsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeChangeTemplatePathsCall) Return(arg0 []string) *MockForgeChangeTemplatePathsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeChangeTemplatePathsCall) Do(f func() []string) *MockForgeChangeTemplatePathsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeChangeTemplatePathsCall) DoAndReturn(f func() []string) *MockForgeChangeTemplatePathsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearAuthenticationToken mocks base method.
func (m *MockForge) ClearAuthenticationToken(arg0 secret.Stash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClearAuthenticationToken", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ClearAuthenticationToken indicates an expected call of ClearAuthenticationToken.
func (mr *MockForgeMockRecorder) ClearAuthenticationToken(arg0 any) *MockForgeClearAuthenticationTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearAuthenticationToken", reflect.TypeOf((*MockForge)(nil).ClearAuthenticationToken), arg0)
	return &MockForgeClearAuthenticationTokenCall{Call: call}
}

// MockForgeClearAuthenticationTokenCall wrap *gomock.Call
type MockForgeClearAuthenticationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeClearAuthenticationTokenCall) Return(arg0 error) *MockForgeClearAuthenticationTokenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeClearAuthenticationTokenCall) Do(f func(secret.Stash) error) *MockForgeClearAuthenticationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeClearAuthenticationTokenCall) DoAndReturn(f func(secret.Stash) error) *MockForgeClearAuthenticationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ID mocks base method.
func (m *MockForge) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockForgeMockRecorder) ID() *MockForgeIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockForge)(nil).ID))
	return &MockForgeIDCall{Call: call}
}

// MockForgeIDCall wrap *gomock.Call
type MockForgeIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeIDCall) Return(arg0 string) *MockForgeIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeIDCall) Do(f func() string) *MockForgeIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeIDCall) DoAndReturn(f func() string) *MockForgeIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoadAuthenticationToken mocks base method.
func (m *MockForge) LoadAuthenticationToken(arg0 secret.Stash) (forge.AuthenticationToken, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadAuthenticationToken", arg0)
	ret0, _ := ret[0].(forge.AuthenticationToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadAuthenticationToken indicates an expected call of LoadAuthenticationToken.
func (mr *MockForgeMockRecorder) LoadAuthenticationToken(arg0 any) *MockForgeLoadAuthenticationTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadAuthenticationToken", reflect.TypeOf((*MockForge)(nil).LoadAuthenticationToken), arg0)
	return &MockForgeLoadAuthenticationTokenCall{Call: call}
}

// MockForgeLoadAuthenticationTokenCall wrap *gomock.Call
type MockForgeLoadAuthenticationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeLoadAuthenticationTokenCall) Return(arg0 forge.AuthenticationToken, arg1 error) *MockForgeLoadAuthenticationTokenCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeLoadAuthenticationTokenCall) Do(f func(secret.Stash) (forge.AuthenticationToken, error)) *MockForgeLoadAuthenticationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeLoadAuthenticationTokenCall) DoAndReturn(f func(secret.Stash) (forge.AuthenticationToken, error)) *MockForgeLoadAuthenticationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MarshalChangeID mocks base method.
func (m *MockForge) MarshalChangeID(arg0 forge.ChangeID) (json.RawMessage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarshalChangeID", arg0)
	ret0, _ := ret[0].(json.RawMessage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MarshalChangeID indicates an expected call of MarshalChangeID.
func (mr *MockForgeMockRecorder) MarshalChangeID(arg0 any) *MockForgeMarshalChangeIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarshalChangeID", reflect.TypeOf((*MockForge)(nil).MarshalChangeID), arg0)
	return &MockForgeMarshalChangeIDCall{Call: call}
}

// MockForgeMarshalChangeIDCall wrap *gomock.Call
type MockForgeMarshalChangeIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeMarshalChangeIDCall) Return(arg0 json.RawMessage, arg1 error) *MockForgeMarshalChangeIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeMarshalChangeIDCall) Do(f func(forge.ChangeID) (json.RawMessage, error)) *MockForgeMarshalChangeIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeMarshalChangeIDCall) DoAndReturn(f func(forge.ChangeID) (json.RawMessage, error)) *MockForgeMarshalChangeIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MarshalChangeMetadata mocks base method.
func (m *MockForge) MarshalChangeMetadata(arg0 forge.ChangeMetadata) (json.RawMessage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarshalChangeMetadata", arg0)
	ret0, _ := ret[0].(json.RawMessage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MarshalChangeMetadata indicates an expected call of MarshalChangeMetadata.
func (mr *MockForgeMockRecorder) MarshalChangeMetadata(arg0 any) *MockForgeMarshalChangeMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarshalChangeMetadata", reflect.TypeOf((*MockForge)(nil).MarshalChangeMetadata), arg0)
	return &MockForgeMarshalChangeMetadataCall{Call: call}
}

// MockForgeMarshalChangeMetadataCall wrap *gomock.Call
type MockForgeMarshalChangeMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeMarshalChangeMetadataCall) Return(arg0 json.RawMessage, arg1 error) *MockForgeMarshalChangeMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeMarshalChangeMetadataCall) Do(f func(forge.ChangeMetadata) (json.RawMessage, error)) *MockForgeMarshalChangeMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeMarshalChangeMetadataCall) DoAndReturn(f func(forge.ChangeMetadata) (json.RawMessage, error)) *MockForgeMarshalChangeMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MatchURL mocks base method.
func (m *MockForge) MatchURL(remoteURL string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MatchURL", remoteURL)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MatchURL indicates an expected call of MatchURL.
func (mr *MockForgeMockRecorder) MatchURL(remoteURL any) *MockForgeMatchURLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MatchURL", reflect.TypeOf((*MockForge)(nil).MatchURL), remoteURL)
	return &MockForgeMatchURLCall{Call: call}
}

// MockForgeMatchURLCall wrap *gomock.Call
type MockForgeMatchURLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeMatchURLCall) Return(arg0 bool) *MockForgeMatchURLCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeMatchURLCall) Do(f func(string) bool) *MockForgeMatchURLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeMatchURLCall) DoAndReturn(f func(string) bool) *MockForgeMatchURLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OpenURL mocks base method.
func (m *MockForge) OpenURL(ctx context.Context, tok forge.AuthenticationToken, remoteURL string) (forge.Repository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenURL", ctx, tok, remoteURL)
	ret0, _ := ret[0].(forge.Repository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenURL indicates an expected call of OpenURL.
func (mr *MockForgeMockRecorder) OpenURL(ctx, tok, remoteURL any) *MockForgeOpenURLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenURL", reflect.TypeOf((*MockForge)(nil).OpenURL), ctx, tok, remoteURL)
	return &MockForgeOpenURLCall{Call: call}
}

// MockForgeOpenURLCall wrap *gomock.Call
type MockForgeOpenURLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeOpenURLCall) Return(arg0 forge.Repository, arg1 error) *MockForgeOpenURLCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeOpenURLCall) Do(f func(context.Context, forge.AuthenticationToken, string) (forge.Repository, error)) *MockForgeOpenURLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeOpenURLCall) DoAndReturn(f func(context.Context, forge.AuthenticationToken, string) (forge.Repository, error)) *MockForgeOpenURLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveAuthenticationToken mocks base method.
func (m *MockForge) SaveAuthenticationToken(arg0 secret.Stash, arg1 forge.AuthenticationToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveAuthenticationToken", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveAuthenticationToken indicates an expected call of SaveAuthenticationToken.
func (mr *MockForgeMockRecorder) SaveAuthenticationToken(arg0, arg1 any) *MockForgeSaveAuthenticationTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAuthenticationToken", reflect.TypeOf((*MockForge)(nil).SaveAuthenticationToken), arg0, arg1)
	return &MockForgeSaveAuthenticationTokenCall{Call: call}
}

// MockForgeSaveAuthenticationTokenCall wrap *gomock.Call
type MockForgeSaveAuthenticationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeSaveAuthenticationTokenCall) Return(arg0 error) *MockForgeSaveAuthenticationTokenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeSaveAuthenticationTokenCall) Do(f func(secret.Stash, forge.AuthenticationToken) error) *MockForgeSaveAuthenticationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeSaveAuthenticationTokenCall) DoAndReturn(f func(secret.Stash, forge.AuthenticationToken) error) *MockForgeSaveAuthenticationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnmarshalChangeID mocks base method.
func (m *MockForge) UnmarshalChangeID(arg0 json.RawMessage) (forge.ChangeID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnmarshalChangeID", arg0)
	ret0, _ := ret[0].(forge.ChangeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnmarshalChangeID indicates an expected call of UnmarshalChangeID.
func (mr *MockForgeMockRecorder) UnmarshalChangeID(arg0 any) *MockForgeUnmarshalChangeIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnmarshalChangeID", reflect.TypeOf((*MockForge)(nil).UnmarshalChangeID), arg0)
	return &MockForgeUnmarshalChangeIDCall{Call: call}
}

// MockForgeUnmarshalChangeIDCall wrap *gomock.Call
type MockForgeUnmarshalChangeIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeUnmarshalChangeIDCall) Return(arg0 forge.ChangeID, arg1 error) *MockForgeUnmarshalChangeIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeUnmarshalChangeIDCall) Do(f func(json.RawMessage) (forge.ChangeID, error)) *MockForgeUnmarshalChangeIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeUnmarshalChangeIDCall) DoAndReturn(f func(json.RawMessage) (forge.ChangeID, error)) *MockForgeUnmarshalChangeIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnmarshalChangeMetadata mocks base method.
func (m *MockForge) UnmarshalChangeMetadata(arg0 json.RawMessage) (forge.ChangeMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnmarshalChangeMetadata", arg0)
	ret0, _ := ret[0].(forge.ChangeMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnmarshalChangeMetadata indicates an expected call of UnmarshalChangeMetadata.
func (mr *MockForgeMockRecorder) UnmarshalChangeMetadata(arg0 any) *MockForgeUnmarshalChangeMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnmarshalChangeMetadata", reflect.TypeOf((*MockForge)(nil).UnmarshalChangeMetadata), arg0)
	return &MockForgeUnmarshalChangeMetadataCall{Call: call}
}

// MockForgeUnmarshalChangeMetadataCall wrap *gomock.Call
type MockForgeUnmarshalChangeMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockForgeUnmarshalChangeMetadataCall) Return(arg0 forge.ChangeMetadata, arg1 error) *MockForgeUnmarshalChangeMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockForgeUnmarshalChangeMetadataCall) Do(f func(json.RawMessage) (forge.ChangeMetadata, error)) *MockForgeUnmarshalChangeMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockForgeUnmarshalChangeMetadataCall) DoAndReturn(f func(json.RawMessage) (forge.ChangeMetadata, error)) *MockForgeUnmarshalChangeMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// ChangesAreMerged mocks base method.
func (m *MockRepository) ChangesAreMerged(ctx context.Context, ids []forge.ChangeID) ([]bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangesAreMerged", ctx, ids)
	ret0, _ := ret[0].([]bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ChangesAreMerged indicates an expected call of ChangesAreMerged.
func (mr *MockRepositoryMockRecorder) ChangesAreMerged(ctx, ids any) *MockRepositoryChangesAreMergedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangesAreMerged", reflect.TypeOf((*MockRepository)(nil).ChangesAreMerged), ctx, ids)
	return &MockRepositoryChangesAreMergedCall{Call: call}
}

// MockRepositoryChangesAreMergedCall wrap *gomock.Call
type MockRepositoryChangesAreMergedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryChangesAreMergedCall) Return(arg0 []bool, arg1 error) *MockRepositoryChangesAreMergedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryChangesAreMergedCall) Do(f func(context.Context, []forge.ChangeID) ([]bool, error)) *MockRepositoryChangesAreMergedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryChangesAreMergedCall) DoAndReturn(f func(context.Context, []forge.ChangeID) ([]bool, error)) *MockRepositoryChangesAreMergedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EditChange mocks base method.
func (m *MockRepository) EditChange(ctx context.Context, id forge.ChangeID, opts forge.EditChangeOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EditChange", ctx, id, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// EditChange indicates an expected call of EditChange.
func (mr *MockRepositoryMockRecorder) EditChange(ctx, id, opts any) *MockRepositoryEditChangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditChange", reflect.TypeOf((*MockRepository)(nil).EditChange), ctx, id, opts)
	return &MockRepositoryEditChangeCall{Call: call}
}

// MockRepositoryEditChangeCall wrap *gomock.Call
type MockRepositoryEditChangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryEditChangeCall) Return(arg0 error) *MockRepositoryEditChangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryEditChangeCall) Do(f func(context.Context, forge.ChangeID, forge.EditChangeOptions) error) *MockRepositoryEditChangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryEditChangeCall) DoAndReturn(f func(context.Context, forge.ChangeID, forge.EditChangeOptions) error) *MockRepositoryEditChangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindChangeByID mocks base method.
func (m *MockRepository) FindChangeByID(ctx context.Context, id forge.ChangeID) (*forge.FindChangeItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindChangeByID", ctx, id)
	ret0, _ := ret[0].(*forge.FindChangeItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindChangeByID indicates an expected call of FindChangeByID.
func (mr *MockRepositoryMockRecorder) FindChangeByID(ctx, id any) *MockRepositoryFindChangeByIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindChangeByID", reflect.TypeOf((*MockRepository)(nil).FindChangeByID), ctx, id)
	return &MockRepositoryFindChangeByIDCall{Call: call}
}

// MockRepositoryFindChangeByIDCall wrap *gomock.Call
type MockRepositoryFindChangeByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindChangeByIDCall) Return(arg0 *forge.FindChangeItem, arg1 error) *MockRepositoryFindChangeByIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindChangeByIDCall) Do(f func(context.Context, forge.ChangeID) (*forge.FindChangeItem, error)) *MockRepositoryFindChangeByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindChangeByIDCall) DoAndReturn(f func(context.Context, forge.ChangeID) (*forge.FindChangeItem, error)) *MockRepositoryFindChangeByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindChangesByBranch mocks base method.
func (m *MockRepository) FindChangesByBranch(ctx context.Context, branch string, opts forge.FindChangesOptions) ([]*forge.FindChangeItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindChangesByBranch", ctx, branch, opts)
	ret0, _ := ret[0].([]*forge.FindChangeItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindChangesByBranch indicates an expected call of FindChangesByBranch.
func (mr *MockRepositoryMockRecorder) FindChangesByBranch(ctx, branch, opts any) *MockRepositoryFindChangesByBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindChangesByBranch", reflect.TypeOf((*MockRepository)(nil).FindChangesByBranch), ctx, branch, opts)
	return &MockRepositoryFindChangesByBranchCall{Call: call}
}

// MockRepositoryFindChangesByBranchCall wrap *gomock.Call
type MockRepositoryFindChangesByBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFindChangesByBranchCall) Return(arg0 []*forge.FindChangeItem, arg1 error) *MockRepositoryFindChangesByBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFindChangesByBranchCall) Do(f func(context.Context, string, forge.FindChangesOptions) ([]*forge.FindChangeItem, error)) *MockRepositoryFindChangesByBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFindChangesByBranchCall) DoAndReturn(f func(context.Context, string, forge.FindChangesOptions) ([]*forge.FindChangeItem, error)) *MockRepositoryFindChangesByBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Forge mocks base method.
func (m *MockRepository) Forge() forge.Forge {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Forge")
	ret0, _ := ret[0].(forge.Forge)
	return ret0
}

// Forge indicates an expected call of Forge.
func (mr *MockRepositoryMockRecorder) Forge() *MockRepositoryForgeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Forge", reflect.TypeOf((*MockRepository)(nil).Forge))
	return &MockRepositoryForgeCall{Call: call}
}

// MockRepositoryForgeCall wrap *gomock.Call
type MockRepositoryForgeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryForgeCall) Return(arg0 forge.Forge) *MockRepositoryForgeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryForgeCall) Do(f func() forge.Forge) *MockRepositoryForgeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryForgeCall) DoAndReturn(f func() forge.Forge) *MockRepositoryForgeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListChangeComments mocks base method.
func (m *MockRepository) ListChangeComments(arg0 context.Context, arg1 forge.ChangeID, arg2 *forge.ListChangeCommentsOptions) iter.Seq2[*forge.ListChangeCommentItem, error] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListChangeComments", arg0, arg1, arg2)
	ret0, _ := ret[0].(iter.Seq2[*forge.ListChangeCommentItem, error])
	return ret0
}

// ListChangeComments indicates an expected call of ListChangeComments.
func (mr *MockRepositoryMockRecorder) ListChangeComments(arg0, arg1, arg2 any) *MockRepositoryListChangeCommentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChangeComments", reflect.TypeOf((*MockRepository)(nil).ListChangeComments), arg0, arg1, arg2)
	return &MockRepositoryListChangeCommentsCall{Call: call}
}

// MockRepositoryListChangeCommentsCall wrap *gomock.Call
type MockRepositoryListChangeCommentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryListChangeCommentsCall) Return(arg0 iter.Seq2[*forge.ListChangeCommentItem, error]) *MockRepositoryListChangeCommentsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryListChangeCommentsCall) Do(f func(context.Context, forge.ChangeID, *forge.ListChangeCommentsOptions) iter.Seq2[*forge.ListChangeCommentItem, error]) *MockRepositoryListChangeCommentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryListChangeCommentsCall) DoAndReturn(f func(context.Context, forge.ChangeID, *forge.ListChangeCommentsOptions) iter.Seq2[*forge.ListChangeCommentItem, error]) *MockRepositoryListChangeCommentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListChangeTemplates mocks base method.
func (m *MockRepository) ListChangeTemplates(arg0 context.Context) ([]*forge.ChangeTemplate, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListChangeTemplates", arg0)
	ret0, _ := ret[0].([]*forge.ChangeTemplate)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListChangeTemplates indicates an expected call of ListChangeTemplates.
func (mr *MockRepositoryMockRecorder) ListChangeTemplates(arg0 any) *MockRepositoryListChangeTemplatesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChangeTemplates", reflect.TypeOf((*MockRepository)(nil).ListChangeTemplates), arg0)
	return &MockRepositoryListChangeTemplatesCall{Call: call}
}

// MockRepositoryListChangeTemplatesCall wrap *gomock.Call
type MockRepositoryListChangeTemplatesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryListChangeTemplatesCall) Return(arg0 []*forge.ChangeTemplate, arg1 error) *MockRepositoryListChangeTemplatesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryListChangeTemplatesCall) Do(f func(context.Context) ([]*forge.ChangeTemplate, error)) *MockRepositoryListChangeTemplatesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryListChangeTemplatesCall) DoAndReturn(f func(context.Context) ([]*forge.ChangeTemplate, error)) *MockRepositoryListChangeTemplatesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewChangeMetadata mocks base method.
func (m *MockRepository) NewChangeMetadata(ctx context.Context, id forge.ChangeID) (forge.ChangeMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewChangeMetadata", ctx, id)
	ret0, _ := ret[0].(forge.ChangeMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewChangeMetadata indicates an expected call of NewChangeMetadata.
func (mr *MockRepositoryMockRecorder) NewChangeMetadata(ctx, id any) *MockRepositoryNewChangeMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewChangeMetadata", reflect.TypeOf((*MockRepository)(nil).NewChangeMetadata), ctx, id)
	return &MockRepositoryNewChangeMetadataCall{Call: call}
}

// MockRepositoryNewChangeMetadataCall wrap *gomock.Call
type MockRepositoryNewChangeMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryNewChangeMetadataCall) Return(arg0 forge.ChangeMetadata, arg1 error) *MockRepositoryNewChangeMetadataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryNewChangeMetadataCall) Do(f func(context.Context, forge.ChangeID) (forge.ChangeMetadata, error)) *MockRepositoryNewChangeMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryNewChangeMetadataCall) DoAndReturn(f func(context.Context, forge.ChangeID) (forge.ChangeMetadata, error)) *MockRepositoryNewChangeMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PostChangeComment mocks base method.
func (m *MockRepository) PostChangeComment(arg0 context.Context, arg1 forge.ChangeID, arg2 string) (forge.ChangeCommentID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostChangeComment", arg0, arg1, arg2)
	ret0, _ := ret[0].(forge.ChangeCommentID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PostChangeComment indicates an expected call of PostChangeComment.
func (mr *MockRepositoryMockRecorder) PostChangeComment(arg0, arg1, arg2 any) *MockRepositoryPostChangeCommentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostChangeComment", reflect.TypeOf((*MockRepository)(nil).PostChangeComment), arg0, arg1, arg2)
	return &MockRepositoryPostChangeCommentCall{Call: call}
}

// MockRepositoryPostChangeCommentCall wrap *gomock.Call
type MockRepositoryPostChangeCommentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryPostChangeCommentCall) Return(arg0 forge.ChangeCommentID, arg1 error) *MockRepositoryPostChangeCommentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryPostChangeCommentCall) Do(f func(context.Context, forge.ChangeID, string) (forge.ChangeCommentID, error)) *MockRepositoryPostChangeCommentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryPostChangeCommentCall) DoAndReturn(f func(context.Context, forge.ChangeID, string) (forge.ChangeCommentID, error)) *MockRepositoryPostChangeCommentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubmitChange mocks base method.
func (m *MockRepository) SubmitChange(ctx context.Context, req forge.SubmitChangeRequest) (forge.SubmitChangeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SubmitChange", ctx, req)
	ret0, _ := ret[0].(forge.SubmitChangeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SubmitChange indicates an expected call of SubmitChange.
func (mr *MockRepositoryMockRecorder) SubmitChange(ctx, req any) *MockRepositorySubmitChangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubmitChange", reflect.TypeOf((*MockRepository)(nil).SubmitChange), ctx, req)
	return &MockRepositorySubmitChangeCall{Call: call}
}

// MockRepositorySubmitChangeCall wrap *gomock.Call
type MockRepositorySubmitChangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositorySubmitChangeCall) Return(arg0 forge.SubmitChangeResult, arg1 error) *MockRepositorySubmitChangeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositorySubmitChangeCall) Do(f func(context.Context, forge.SubmitChangeRequest) (forge.SubmitChangeResult, error)) *MockRepositorySubmitChangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositorySubmitChangeCall) DoAndReturn(f func(context.Context, forge.SubmitChangeRequest) (forge.SubmitChangeResult, error)) *MockRepositorySubmitChangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChangeComment mocks base method.
func (m *MockRepository) UpdateChangeComment(arg0 context.Context, arg1 forge.ChangeCommentID, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateChangeComment", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateChangeComment indicates an expected call of UpdateChangeComment.
func (mr *MockRepositoryMockRecorder) UpdateChangeComment(arg0, arg1, arg2 any) *MockRepositoryUpdateChangeCommentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChangeComment", reflect.TypeOf((*MockRepository)(nil).UpdateChangeComment), arg0, arg1, arg2)
	return &MockRepositoryUpdateChangeCommentCall{Call: call}
}

// MockRepositoryUpdateChangeCommentCall wrap *gomock.Call
type MockRepositoryUpdateChangeCommentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryUpdateChangeCommentCall) Return(arg0 error) *MockRepositoryUpdateChangeCommentCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryUpdateChangeCommentCall) Do(f func(context.Context, forge.ChangeCommentID, string) error) *MockRepositoryUpdateChangeCommentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryUpdateChangeCommentCall) DoAndReturn(f func(context.Context, forge.ChangeCommentID, string) error) *MockRepositoryUpdateChangeCommentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
