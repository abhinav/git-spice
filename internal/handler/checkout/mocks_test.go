// Code generated by MockGen. DO NOT EDIT.
// Source: go.abhg.dev/gs/internal/handler/checkout (interfaces: GitWorktree,TrackHandler,Service,Store)
//
// Generated by this command:
//
//	mockgen -destination mocks_test.go -package checkout -typed . GitWorktree,TrackHandler,Service,Store
//

// Package checkout is a generated GoMock package.
package checkout

import (
	context "context"
	reflect "reflect"

	track "go.abhg.dev/gs/internal/handler/track"
	gomock "go.uber.org/mock/gomock"
)

// MockGitWorktree is a mock of GitWorktree interface.
type MockGitWorktree struct {
	ctrl     *gomock.Controller
	recorder *MockGitWorktreeMockRecorder
	isgomock struct{}
}

// MockGitWorktreeMockRecorder is the mock recorder for MockGitWorktree.
type MockGitWorktreeMockRecorder struct {
	mock *MockGitWorktree
}

// NewMockGitWorktree creates a new mock instance.
func NewMockGitWorktree(ctrl *gomock.Controller) *MockGitWorktree {
	mock := &MockGitWorktree{ctrl: ctrl}
	mock.recorder = &MockGitWorktreeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitWorktree) EXPECT() *MockGitWorktreeMockRecorder {
	return m.recorder
}

// Checkout mocks base method.
func (m *MockGitWorktree) Checkout(ctx context.Context, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Checkout", ctx, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// Checkout indicates an expected call of Checkout.
func (mr *MockGitWorktreeMockRecorder) Checkout(ctx, branch any) *MockGitWorktreeCheckoutCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Checkout", reflect.TypeOf((*MockGitWorktree)(nil).Checkout), ctx, branch)
	return &MockGitWorktreeCheckoutCall{Call: call}
}

// MockGitWorktreeCheckoutCall wrap *gomock.Call
type MockGitWorktreeCheckoutCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitWorktreeCheckoutCall) Return(arg0 error) *MockGitWorktreeCheckoutCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitWorktreeCheckoutCall) Do(f func(context.Context, string) error) *MockGitWorktreeCheckoutCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitWorktreeCheckoutCall) DoAndReturn(f func(context.Context, string) error) *MockGitWorktreeCheckoutCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DetachHead mocks base method.
func (m *MockGitWorktree) DetachHead(ctx context.Context, commitish string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DetachHead", ctx, commitish)
	ret0, _ := ret[0].(error)
	return ret0
}

// DetachHead indicates an expected call of DetachHead.
func (mr *MockGitWorktreeMockRecorder) DetachHead(ctx, commitish any) *MockGitWorktreeDetachHeadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachHead", reflect.TypeOf((*MockGitWorktree)(nil).DetachHead), ctx, commitish)
	return &MockGitWorktreeDetachHeadCall{Call: call}
}

// MockGitWorktreeDetachHeadCall wrap *gomock.Call
type MockGitWorktreeDetachHeadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitWorktreeDetachHeadCall) Return(arg0 error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitWorktreeDetachHeadCall) Do(f func(context.Context, string) error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitWorktreeDetachHeadCall) DoAndReturn(f func(context.Context, string) error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTrackHandler is a mock of TrackHandler interface.
type MockTrackHandler struct {
	ctrl     *gomock.Controller
	recorder *MockTrackHandlerMockRecorder
	isgomock struct{}
}

// MockTrackHandlerMockRecorder is the mock recorder for MockTrackHandler.
type MockTrackHandlerMockRecorder struct {
	mock *MockTrackHandler
}

// NewMockTrackHandler creates a new mock instance.
func NewMockTrackHandler(ctrl *gomock.Controller) *MockTrackHandler {
	mock := &MockTrackHandler{ctrl: ctrl}
	mock.recorder = &MockTrackHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTrackHandler) EXPECT() *MockTrackHandlerMockRecorder {
	return m.recorder
}

// AddBranch mocks base method.
func (m *MockTrackHandler) AddBranch(ctx context.Context, req *track.AddBranchRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddBranch", ctx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddBranch indicates an expected call of AddBranch.
func (mr *MockTrackHandlerMockRecorder) AddBranch(ctx, req any) *MockTrackHandlerAddBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBranch", reflect.TypeOf((*MockTrackHandler)(nil).AddBranch), ctx, req)
	return &MockTrackHandlerAddBranchCall{Call: call}
}

// MockTrackHandlerAddBranchCall wrap *gomock.Call
type MockTrackHandlerAddBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTrackHandlerAddBranchCall) Return(arg0 error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTrackHandlerAddBranchCall) Do(f func(context.Context, *track.AddBranchRequest) error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTrackHandlerAddBranchCall) DoAndReturn(f func(context.Context, *track.AddBranchRequest) error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockService is a mock of Service interface.
type MockService struct {
	ctrl     *gomock.Controller
	recorder *MockServiceMockRecorder
	isgomock struct{}
}

// MockServiceMockRecorder is the mock recorder for MockService.
type MockServiceMockRecorder struct {
	mock *MockService
}

// NewMockService creates a new mock instance.
func NewMockService(ctrl *gomock.Controller) *MockService {
	mock := &MockService{ctrl: ctrl}
	mock.recorder = &MockServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockService) EXPECT() *MockServiceMockRecorder {
	return m.recorder
}

// VerifyRestacked mocks base method.
func (m *MockService) VerifyRestacked(ctx context.Context, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyRestacked", ctx, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyRestacked indicates an expected call of VerifyRestacked.
func (mr *MockServiceMockRecorder) VerifyRestacked(ctx, branch any) *MockServiceVerifyRestackedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyRestacked", reflect.TypeOf((*MockService)(nil).VerifyRestacked), ctx, branch)
	return &MockServiceVerifyRestackedCall{Call: call}
}

// MockServiceVerifyRestackedCall wrap *gomock.Call
type MockServiceVerifyRestackedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceVerifyRestackedCall) Return(arg0 error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceVerifyRestackedCall) Do(f func(context.Context, string) error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceVerifyRestackedCall) DoAndReturn(f func(context.Context, string) error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Trunk mocks base method.
func (m *MockStore) Trunk() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Trunk")
	ret0, _ := ret[0].(string)
	return ret0
}

// Trunk indicates an expected call of Trunk.
func (mr *MockStoreMockRecorder) Trunk() *MockStoreTrunkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trunk", reflect.TypeOf((*MockStore)(nil).Trunk))
	return &MockStoreTrunkCall{Call: call}
}

// MockStoreTrunkCall wrap *gomock.Call
type MockStoreTrunkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreTrunkCall) Return(arg0 string) *MockStoreTrunkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreTrunkCall) Do(f func() string) *MockStoreTrunkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreTrunkCall) DoAndReturn(f func() string) *MockStoreTrunkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
