// Code generated by MockGen. DO NOT EDIT.
// Source: go.abhg.dev/gs/internal/handler/checkout (interfaces: GitRepository,GitWorktree,TrackHandler,Service,Store)
//
// Generated by this command:
//
//	mockgen -destination mocks_test.go -package checkout -typed . GitRepository,GitWorktree,TrackHandler,Service,Store
//

// Package checkout is a generated GoMock package.
package checkout

import (
	context "context"
	reflect "reflect"

	git "go.abhg.dev/gs/internal/git"
	track "go.abhg.dev/gs/internal/handler/track"
	gomock "go.uber.org/mock/gomock"
)

// MockGitRepository is a mock of GitRepository interface.
type MockGitRepository struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepositoryMockRecorder
	isgomock struct{}
}

// MockGitRepositoryMockRecorder is the mock recorder for MockGitRepository.
type MockGitRepositoryMockRecorder struct {
	mock *MockGitRepository
}

// NewMockGitRepository creates a new mock instance.
func NewMockGitRepository(ctrl *gomock.Controller) *MockGitRepository {
	mock := &MockGitRepository{ctrl: ctrl}
	mock.recorder = &MockGitRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepository) EXPECT() *MockGitRepositoryMockRecorder {
	return m.recorder
}

// CreateBranch mocks base method.
func (m *MockGitRepository) CreateBranch(ctx context.Context, req git.CreateBranchRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranch", ctx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBranch indicates an expected call of CreateBranch.
func (mr *MockGitRepositoryMockRecorder) CreateBranch(ctx, req any) *MockGitRepositoryCreateBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockGitRepository)(nil).CreateBranch), ctx, req)
	return &MockGitRepositoryCreateBranchCall{Call: call}
}

// MockGitRepositoryCreateBranchCall wrap *gomock.Call
type MockGitRepositoryCreateBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepositoryCreateBranchCall) Return(arg0 error) *MockGitRepositoryCreateBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepositoryCreateBranchCall) Do(f func(context.Context, git.CreateBranchRequest) error) *MockGitRepositoryCreateBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepositoryCreateBranchCall) DoAndReturn(f func(context.Context, git.CreateBranchRequest) error) *MockGitRepositoryCreateBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PeelToCommit mocks base method.
func (m *MockGitRepository) PeelToCommit(ctx context.Context, ref string) (git.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeelToCommit", ctx, ref)
	ret0, _ := ret[0].(git.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PeelToCommit indicates an expected call of PeelToCommit.
func (mr *MockGitRepositoryMockRecorder) PeelToCommit(ctx, ref any) *MockGitRepositoryPeelToCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeelToCommit", reflect.TypeOf((*MockGitRepository)(nil).PeelToCommit), ctx, ref)
	return &MockGitRepositoryPeelToCommitCall{Call: call}
}

// MockGitRepositoryPeelToCommitCall wrap *gomock.Call
type MockGitRepositoryPeelToCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepositoryPeelToCommitCall) Return(arg0 git.Hash, arg1 error) *MockGitRepositoryPeelToCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepositoryPeelToCommitCall) Do(f func(context.Context, string) (git.Hash, error)) *MockGitRepositoryPeelToCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepositoryPeelToCommitCall) DoAndReturn(f func(context.Context, string) (git.Hash, error)) *MockGitRepositoryPeelToCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBranchUpstream mocks base method.
func (m *MockGitRepository) SetBranchUpstream(ctx context.Context, branch, upstream string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBranchUpstream", ctx, branch, upstream)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetBranchUpstream indicates an expected call of SetBranchUpstream.
func (mr *MockGitRepositoryMockRecorder) SetBranchUpstream(ctx, branch, upstream any) *MockGitRepositorySetBranchUpstreamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBranchUpstream", reflect.TypeOf((*MockGitRepository)(nil).SetBranchUpstream), ctx, branch, upstream)
	return &MockGitRepositorySetBranchUpstreamCall{Call: call}
}

// MockGitRepositorySetBranchUpstreamCall wrap *gomock.Call
type MockGitRepositorySetBranchUpstreamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepositorySetBranchUpstreamCall) Return(arg0 error) *MockGitRepositorySetBranchUpstreamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepositorySetBranchUpstreamCall) Do(f func(context.Context, string, string) error) *MockGitRepositorySetBranchUpstreamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepositorySetBranchUpstreamCall) DoAndReturn(f func(context.Context, string, string) error) *MockGitRepositorySetBranchUpstreamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockGitWorktree is a mock of GitWorktree interface.
type MockGitWorktree struct {
	ctrl     *gomock.Controller
	recorder *MockGitWorktreeMockRecorder
	isgomock struct{}
}

// MockGitWorktreeMockRecorder is the mock recorder for MockGitWorktree.
type MockGitWorktreeMockRecorder struct {
	mock *MockGitWorktree
}

// NewMockGitWorktree creates a new mock instance.
func NewMockGitWorktree(ctrl *gomock.Controller) *MockGitWorktree {
	mock := &MockGitWorktree{ctrl: ctrl}
	mock.recorder = &MockGitWorktreeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitWorktree) EXPECT() *MockGitWorktreeMockRecorder {
	return m.recorder
}

// CheckoutBranch mocks base method.
func (m *MockGitWorktree) CheckoutBranch(ctx context.Context, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckoutBranch", ctx, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckoutBranch indicates an expected call of CheckoutBranch.
func (mr *MockGitWorktreeMockRecorder) CheckoutBranch(ctx, branch any) *MockGitWorktreeCheckoutBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckoutBranch", reflect.TypeOf((*MockGitWorktree)(nil).CheckoutBranch), ctx, branch)
	return &MockGitWorktreeCheckoutBranchCall{Call: call}
}

// MockGitWorktreeCheckoutBranchCall wrap *gomock.Call
type MockGitWorktreeCheckoutBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitWorktreeCheckoutBranchCall) Return(arg0 error) *MockGitWorktreeCheckoutBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitWorktreeCheckoutBranchCall) Do(f func(context.Context, string) error) *MockGitWorktreeCheckoutBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitWorktreeCheckoutBranchCall) DoAndReturn(f func(context.Context, string) error) *MockGitWorktreeCheckoutBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DetachHead mocks base method.
func (m *MockGitWorktree) DetachHead(ctx context.Context, commitish string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DetachHead", ctx, commitish)
	ret0, _ := ret[0].(error)
	return ret0
}

// DetachHead indicates an expected call of DetachHead.
func (mr *MockGitWorktreeMockRecorder) DetachHead(ctx, commitish any) *MockGitWorktreeDetachHeadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachHead", reflect.TypeOf((*MockGitWorktree)(nil).DetachHead), ctx, commitish)
	return &MockGitWorktreeDetachHeadCall{Call: call}
}

// MockGitWorktreeDetachHeadCall wrap *gomock.Call
type MockGitWorktreeDetachHeadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitWorktreeDetachHeadCall) Return(arg0 error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitWorktreeDetachHeadCall) Do(f func(context.Context, string) error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitWorktreeDetachHeadCall) DoAndReturn(f func(context.Context, string) error) *MockGitWorktreeDetachHeadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTrackHandler is a mock of TrackHandler interface.
type MockTrackHandler struct {
	ctrl     *gomock.Controller
	recorder *MockTrackHandlerMockRecorder
	isgomock struct{}
}

// MockTrackHandlerMockRecorder is the mock recorder for MockTrackHandler.
type MockTrackHandlerMockRecorder struct {
	mock *MockTrackHandler
}

// NewMockTrackHandler creates a new mock instance.
func NewMockTrackHandler(ctrl *gomock.Controller) *MockTrackHandler {
	mock := &MockTrackHandler{ctrl: ctrl}
	mock.recorder = &MockTrackHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTrackHandler) EXPECT() *MockTrackHandlerMockRecorder {
	return m.recorder
}

// AddBranch mocks base method.
func (m *MockTrackHandler) AddBranch(ctx context.Context, req *track.AddBranchRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddBranch", ctx, req)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddBranch indicates an expected call of AddBranch.
func (mr *MockTrackHandlerMockRecorder) AddBranch(ctx, req any) *MockTrackHandlerAddBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBranch", reflect.TypeOf((*MockTrackHandler)(nil).AddBranch), ctx, req)
	return &MockTrackHandlerAddBranchCall{Call: call}
}

// MockTrackHandlerAddBranchCall wrap *gomock.Call
type MockTrackHandlerAddBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTrackHandlerAddBranchCall) Return(arg0 error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTrackHandlerAddBranchCall) Do(f func(context.Context, *track.AddBranchRequest) error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTrackHandlerAddBranchCall) DoAndReturn(f func(context.Context, *track.AddBranchRequest) error) *MockTrackHandlerAddBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockService is a mock of Service interface.
type MockService struct {
	ctrl     *gomock.Controller
	recorder *MockServiceMockRecorder
	isgomock struct{}
}

// MockServiceMockRecorder is the mock recorder for MockService.
type MockServiceMockRecorder struct {
	mock *MockService
}

// NewMockService creates a new mock instance.
func NewMockService(ctrl *gomock.Controller) *MockService {
	mock := &MockService{ctrl: ctrl}
	mock.recorder = &MockServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockService) EXPECT() *MockServiceMockRecorder {
	return m.recorder
}

// VerifyRestacked mocks base method.
func (m *MockService) VerifyRestacked(ctx context.Context, branch string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyRestacked", ctx, branch)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyRestacked indicates an expected call of VerifyRestacked.
func (mr *MockServiceMockRecorder) VerifyRestacked(ctx, branch any) *MockServiceVerifyRestackedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyRestacked", reflect.TypeOf((*MockService)(nil).VerifyRestacked), ctx, branch)
	return &MockServiceVerifyRestackedCall{Call: call}
}

// MockServiceVerifyRestackedCall wrap *gomock.Call
type MockServiceVerifyRestackedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceVerifyRestackedCall) Return(arg0 error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceVerifyRestackedCall) Do(f func(context.Context, string) error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceVerifyRestackedCall) DoAndReturn(f func(context.Context, string) error) *MockServiceVerifyRestackedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Remote mocks base method.
func (m *MockStore) Remote() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remote")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Remote indicates an expected call of Remote.
func (mr *MockStoreMockRecorder) Remote() *MockStoreRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remote", reflect.TypeOf((*MockStore)(nil).Remote))
	return &MockStoreRemoteCall{Call: call}
}

// MockStoreRemoteCall wrap *gomock.Call
type MockStoreRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreRemoteCall) Return(arg0 string, arg1 error) *MockStoreRemoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreRemoteCall) Do(f func() (string, error)) *MockStoreRemoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreRemoteCall) DoAndReturn(f func() (string, error)) *MockStoreRemoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Trunk mocks base method.
func (m *MockStore) Trunk() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Trunk")
	ret0, _ := ret[0].(string)
	return ret0
}

// Trunk indicates an expected call of Trunk.
func (mr *MockStoreMockRecorder) Trunk() *MockStoreTrunkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trunk", reflect.TypeOf((*MockStore)(nil).Trunk))
	return &MockStoreTrunkCall{Call: call}
}

// MockStoreTrunkCall wrap *gomock.Call
type MockStoreTrunkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreTrunkCall) Return(arg0 string) *MockStoreTrunkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreTrunkCall) Do(f func() string) *MockStoreTrunkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreTrunkCall) DoAndReturn(f func() string) *MockStoreTrunkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
