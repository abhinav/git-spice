package gs

import (
	"context"
	"errors"
	"fmt"
	"slices"
	"strings"
	"unicode"

	"github.com/charmbracelet/log"
	"go.abhg.dev/gs/internal/git"
	"go.abhg.dev/gs/internal/must"
	"go.abhg.dev/gs/internal/state"
)

const _generatedBranchNameLimit = 32

// GenerateBranchName generates a branch name from a commit message subject.
//
// The branch name is generated by converting the subject to lowercase,
// replacing spaces with hyphens, and removing all non-alphanumeric characters.
//
// If the subject has more than 32 characters, it is truncated to 32 characters
// at word boundaries.
func GenerateBranchName(subject string) string {
	words := strings.FieldsFunc(strings.ToLower(subject), func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsNumber(r)
	})
	must.NotBeEmptyf(words, "subject must not be empty")

	var name strings.Builder
	for _, w := range words {
		newLen := name.Len() + len(w)
		needHyphen := name.Len() > 0
		if needHyphen {
			newLen++
		}

		if newLen > _generatedBranchNameLimit {
			break
		}

		if needHyphen {
			name.WriteByte('-')
		}
		for _, r := range w {
			name.WriteRune(unicode.ToLower(r))
		}
	}

	return name.String()
}

type branchInfo struct {
	*state.LookupResponse
	Name string
}

func (s *Service) allBranches(ctx context.Context) ([]branchInfo, error) {
	names, err := s.store.List(ctx)
	if err != nil {
		return nil, fmt.Errorf("list branches: %w", err)
	}

	infos := make([]branchInfo, 0, len(names))

	deletes := make(map[string]*state.LookupResponse)
	var update state.UpdateRequest
	for _, name := range names {
		resp, err := s.store.Lookup(ctx, name)
		if err != nil {
			return nil, fmt.Errorf("get branch %v: %w", name, err)
		}

		// If the branch has been deleted out of band,
		// pretend like it doesn't exist.
		if _, err := s.repo.PeelToCommit(ctx, name); err != nil {
			if !errors.Is(err, git.ErrNotExist) {
				return nil, fmt.Errorf("resolve branch %q: %w", name, err)
			}

			log.Infof("%v: branch deleted outside gs: removing", name)
			deletes[name] = resp
			continue
		}

		// If the base branch of this branch has been deleted,
		// use its base, or its base's base, and so on,
		// and update the state to reflect the change.
		var changed bool
		for base, deleted := deletes[resp.Base]; deleted; base, deleted = deletes[resp.Base] {
			resp.Base = base.Base
			resp.BaseHash = base.BaseHash
			changed = true
		}

		if changed {
			update.Upserts = append(update.Upserts, state.UpsertRequest{
				Name:     name,
				Base:     resp.Base,
				BaseHash: resp.BaseHash,
			})
		}

		infos = append(infos, branchInfo{
			Name:           name,
			LookupResponse: resp,
		})
	}

	if len(deletes) > 0 {
		update.Deletes = make([]string, 0, len(deletes))
		for name := range deletes {
			update.Deletes = append(update.Deletes, name)
		}

		update.Message = "clean up deleted branches"
		if err := s.store.Update(ctx, &update); err != nil {
			log.Warn("Error updating state with deleted branches", "err", err)
		}
	}

	return infos, nil
}

func (s *Service) branchesByBase(ctx context.Context) (map[string][]string, error) {
	branchesByBase := make(map[string][]string)
	branches, err := s.allBranches(ctx)
	if err != nil {
		return nil, err
	}
	for _, branch := range branches {
		branchesByBase[branch.Base] = append(
			branchesByBase[branch.Base], branch.Name,
		)
	}
	return branchesByBase, nil
}

// ListAbove returns a list of branches that are immediately above the given branch.
// These are branches that have the given branch as their base.
// The slice is empty if there are no branches above the given branch.
func (s *Service) ListAbove(ctx context.Context, base string) ([]string, error) {
	var children []string
	branches, err := s.allBranches(ctx)
	if err != nil {
		return nil, err
	}
	for _, branch := range branches {
		if branch.Base == base {
			children = append(children, branch.Name)
		}
	}

	return children, nil
}

// ListUpstack will list all branches that are upstack from the given branch,
// including those that are upstack from the upstack branches.
// The given branch is the first element in the returned slice.
//
// The returned slice is ordered by branch position in the upstack.
// It is guaranteed that for i < j, branch[i] is not a parent of branch[j].
func (s *Service) ListUpstack(ctx context.Context, start string) ([]string, error) {
	branchesByBase, err := s.branchesByBase(ctx) // base -> [branches]
	if err != nil {
		return nil, err
	}

	var upstacks []string
	remaining := []string{start}
	for len(remaining) > 0 {
		current := remaining[0]
		remaining = remaining[1:]
		upstacks = append(upstacks, current)
		remaining = append(remaining, branchesByBase[current]...)
	}
	must.NotBeEmptyf(upstacks, "there must be at least one branch")
	must.BeEqualf(start, upstacks[0], "starting branch must be first upstack")

	return upstacks, nil
}

// FindTop returns the topmost branches in each upstack chain
// starting at the given branch.
func (s *Service) FindTop(ctx context.Context, start string) ([]string, error) {
	branchesByBase, err := s.branchesByBase(ctx) // base -> [branches]
	if err != nil {
		return nil, err
	}

	remaining := []string{start}
	var tops []string
	for len(remaining) > 0 {
		var b string
		b, remaining = remaining[0], remaining[1:]

		aboves := branchesByBase[b]
		if len(aboves) == 0 {
			// There's nothing above this branch
			// so it's a top-most branch.
			tops = append(tops, b)
		} else {
			remaining = append(remaining, aboves...)
		}
	}
	must.NotBeEmptyf(tops, "at least start branch (%v) must be in tops", start)
	return tops, nil
}

// ListDownstack lists all branches below the given branch
// in the downstack chain, not including trunk.
//
// The given branch is the first element in the returned slice,
// and the bottom-most branch is the last element.
func (s *Service) ListDownstack(ctx context.Context, start string) ([]string, error) {
	if start == s.store.Trunk() {
		return nil, nil // nothing downstack from trunk
	}

	downstacks := []string{start}
	current := start
	for {
		b, err := s.store.Lookup(ctx, current)
		if err != nil {
			return nil, fmt.Errorf("lookup %v: %w", current, err)
		}

		if b.Base == s.store.Trunk() {
			return downstacks, nil
		}

		current = b.Base
		downstacks = append(downstacks, current)
	}
}

// FindBottom returns the bottom-most branch in the downstack chain
// starting at the given branch just before trunk.
func (s *Service) FindBottom(ctx context.Context, start string) (string, error) {
	must.NotBeEqualf(start, s.store.Trunk(), "start branch must not be trunk")

	current := start
	for {
		b, err := s.store.Lookup(ctx, current)
		if err != nil {
			return "", fmt.Errorf("lookup %v: %w", current, err)
		}

		if b.Base == s.store.Trunk() {
			return current, nil
		}

		current = b.Base
	}
}

// ListStack returns the full stack of branches that the given branch is in.
//
// If the start branch has multiple upstack branches,
// all of them are included in the returned slice.
// The result is ordered by branch position in the stack
// with the bottom-most branch as the first element.
func (s *Service) ListStack(ctx context.Context, start string) ([]string, error) {
	var downstacks []string
	if start != s.store.Trunk() {
		var err error
		downstacks, err = s.ListDownstack(ctx, start)
		if err != nil {
			return nil, fmt.Errorf("get downstack branches: %w", err)
		}

		must.NotBeEmptyf(downstacks, "downstack branches must not be empty")
		must.BeEqualf(start, downstacks[0], "current branch must be first downstack")
		downstacks = downstacks[1:] // Remove current branch from list
		slices.Reverse(downstacks)
	}

	upstacks, err := s.ListUpstack(ctx, start)
	if err != nil {
		return nil, fmt.Errorf("get upstack branches: %w", err)
	}
	must.NotBeEmptyf(upstacks, "upstack branches must not be empty")
	must.BeEqualf(start, upstacks[0], "current branch must be first upstack")

	stack := make([]string, 0, len(downstacks)+len(upstacks))
	stack = append(stack, downstacks...)
	stack = append(stack, upstacks...)
	return stack, nil
}
